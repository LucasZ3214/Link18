    def draw_compass_rose(self, painter, x, y, radius, heading_rad, others=None, local_player=None):
        if others is None:
            others = []
        
        # Clip drawing to the Compass Circle to contain Waypoint Lines
        painter.save()
        clip_path = QPainterPath()
        clip_path.addEllipse(QPointF(x, y), radius, radius)
        painter.setClipPath(clip_path)

        heading_deg = math.degrees(heading_rad)
        
        # Draw Planning Lines (Bottom Layer)
        if self.planning_waypoints and local_player and self.map_min and self.map_max:
            p_x = local_player.get('x', 0)
            p_y = local_player.get('y', 0)
            
            # Map Dimensions for Normalized -> Meters
            m_min = self.map_min
            m_max = self.map_max
            
            world_w = m_max[0] - m_min[0]
            world_h = m_max[1] - m_min[1]
            
            # Display Scale: Radius = 50km (50,000m)
            disp_range_m = 50000 
            scale = radius / disp_range_m
            
            painter.setPen(QPen(QColor('#00FFFF'), 2)) # Cyan Lines
            
            pts_screen = []
            
            # Convert all WPs to Screen Relative
            for wp in self.planning_waypoints:
                dx_norm = wp['x'] - p_x
                dy_norm = wp['y'] - p_y
                
                dx_m = dx_norm * world_w
                dy_m = dy_norm * world_h
                
                # Use same formula as player positioning (line 1553)
                # bearing from atan2(dy, dx), then: bearing_deg - heading_deg - 90
                bearing_rad = math.atan2(dy_m, dx_m)
                bearing_deg = math.degrees(bearing_rad)
                screen_angle_deg = bearing_deg - heading_deg - 90
                screen_angle = math.radians(screen_angle_deg)
                
                dist_m = math.hypot(dx_m, dy_m)
                r_px = dist_m * scale
                
                sx = x + math.cos(screen_angle) * r_px
                sy = y + math.sin(screen_angle) * r_px
                
                pts_screen.append(QPointF(sx, sy))
            
            # Draw Lines
            if len(pts_screen) > 1:
                path = QPainterPath()
                path.moveTo(pts_screen[0])
                for i in range(1, len(pts_screen)):
                    path.lineTo(pts_screen[i])
                painter.drawPath(path)
                
            # Draw Dots
            painter.setBrush(QColor('#00FFFF'))
            painter.setPen(Qt.PenStyle.NoPen)
            for pt in pts_screen:
                painter.drawEllipse(pt, 3, 3)
                
        painter.restore() # End Clipping

            
        heading_deg = math.degrees(heading_rad)
        
        # PRE-CALCULATE TICKS
        # We need to iterate twice (Black pass, White pass). 
        # So pre-calc geometry to avoid duplication.
        ticks = []
        for i in range(0, 360, 15):
             # Angle formula (Heading Up)
             # screen_angle_deg = (i - 90) - heading_deg - 90 (?)
             # Wait, logic from previous step:
             # Ticks: Target = i - 90 (North=-90).
             # Compass Rotation = -Heading - 90.
             # Result = (i - 90) - heading_deg - 90.
             # Correct.
             
             screen_angle_deg = (i - 90) - heading_deg - 90
             rad = math.radians(screen_angle_deg)
             
             is_cardinal = (i % 90 == 0)
             is_inter = (i % 45 == 0)
             
             if is_cardinal:
                 tick_len = 10
                 tick_width = 3.0
                 outline_inc = 2.5 # Bold for Cardinals
                 color = QColor(255, 255, 255, 255)
                 label_text = ""
                 if i == 0: label_text = "N"
                 elif i == 90: label_text = "E"
                 elif i == 180: label_text = "S"
                 elif i == 270: label_text = "W"
                 
             elif is_inter:
                 tick_len = 8
                 tick_width = 2.5
                 outline_inc = 2.5
                 color = QColor(255, 255, 255, 230)
                 label_text = ""
                 if i == 45: label_text = "NE"
                 elif i == 135: label_text = "SE"
                 elif i == 225: label_text = "SW"
                 elif i == 315: label_text = "NW"
                 
             else:
                 tick_len = 5
                 tick_width = 1.5
                 outline_inc = 1.5
                 color = QColor(255, 255, 255, 150)
                 label_text = ""
                 
             # Geometry for Radial Line (Crossing the ring)
             p1_x = x + math.cos(rad) * (radius - tick_len)
             p1_y = y + math.sin(rad) * (radius - tick_len)
             p2_x = x + math.cos(rad) * (radius + tick_len)
             p2_y = y + math.sin(rad) * (radius + tick_len)
             
             ticks.append({
                 'p1': QPointF(p1_x, p1_y),
                 'p2': QPointF(p2_x, p2_y),
                 'width': tick_width,
                 'outline_w': tick_width + outline_inc,
                 'color': color,
                 'label': label_text,
                 'rad': rad
             })
             
        # Add POI Ticks (Merged into seamless rendering)
        for item in others:
            if item.get('type') == 'poi':
                bearing = item.get('bearing', 0)
                color = item.get('color', QColor(255, 255, 0)) # Default Yellow
                
                # Turn bearing into screen angle
                bearing_deg = math.degrees(bearing)
                screen_angle_deg = bearing_deg - heading_deg - 90
                rad = math.radians(screen_angle_deg)
                
                # Cardinal Style
                tick_len = 10
                tick_width = 3.0
                outline_inc = 2.5
                
                p1_x = x + math.cos(rad) * (radius - tick_len)
                p1_y = y + math.sin(rad) * (radius - tick_len)
                p2_x = x + math.cos(rad) * (radius + tick_len)
                p2_y = y + math.sin(rad) * (radius + tick_len)
                
                ticks.append({
                     'p1': QPointF(p1_x, p1_y),
                     'p2': QPointF(p2_x, p2_y),
                     'width': tick_width,
                     'outline_w': tick_width + outline_inc,
                     'color': color,
                     'label': "", # No label for POI tick itself (maybe owner name elsewhere?)
                     'rad': rad
                 })

        # PASS 1: BLACK OUTLINE (Ring + Ticks)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        
        # Ring Outline
        painter.setPen(QPen(QColor(0, 0, 0, 255), 4.5))
        painter.drawEllipse(QPointF(x, y), radius, radius)
        
        # Ticks Outline
        for t in ticks:
            pen = QPen(QColor(0,0,0, 255), t['outline_w'])
            pen.setCapStyle(Qt.PenCapStyle.RoundCap) # Round caps for outline
            painter.setPen(pen)
            painter.drawLine(t['p1'], t['p2'])
            
        # PASS 2: WHITE FILL (Ring + Ticks)
        
        # Ring Fill
        painter.setPen(QPen(QColor(255, 255, 255, 230), 2.5))
        painter.drawEllipse(QPointF(x, y), radius, radius)
        
        # Ticks Fill
        for t in ticks:
            pen = QPen(t['color'], t['width'])
            pen.setCapStyle(Qt.PenCapStyle.FlatCap) # Butt/Flat caps for inner
            painter.setPen(pen)
            painter.drawLine(t['p1'], t['p2'])

        # LABELS (Drawn on top)
        painter.setFont(QFont("Consolas", 10, QFont.Weight.Bold))
        fm = painter.fontMetrics()
        
        for t in ticks:
             if t['label']:
                 r_text = radius - 25
                 tx = x + math.cos(t['rad']) * r_text
                 ty = y + math.sin(t['rad']) * r_text
                 
                 is_card = (len(t['label']) == 1)
                 font_size = 12 if is_card else 10
                 painter.setFont(QFont("Consolas", font_size, QFont.Weight.Bold))
                 fm = painter.fontMetrics()
                 tw = fm.horizontalAdvance(t['label'])
                 th = fm.height()
                 
                 # Outline Text
                 painter.setPen(QPen(QColor(0,0,0), 3))
                 painter.drawText(int(tx - tw/2), int(ty + th/4), t['label'])
                 
                # Fill Text
                 painter.setPen(QColor(255,255,255))
                 painter.drawText(int(tx - tw/2), int(ty + th/4), t['label'])
                 

        # Draw Others (Players) - Separate Pass for Triangles (On Top)
        # POIs are now handled as Ticks above.
        
        for item in others:
            if item.get('type') == 'poi':
                continue # Already drawn as tick
                
            # Players (Triangles)
            bearing = item.get('bearing', 0)
            color = item.get('color', QColor(255, 255, 255))
            label_text = item.get('label', '') 
            
            # Angle on screen
            bearing_deg = math.degrees(bearing)
            screen_angle_deg = bearing_deg - heading_deg - 90
            item_rad = math.radians(screen_angle_deg)
            
            ix = x + math.cos(item_rad) * radius
            iy = y + math.sin(item_rad) * radius
            
            painter.save()
            painter.translate(ix, iy)
            # Rotate to point INWARD (matching HDG marker style)
            # Shape points Right (0 deg).
            # We want it pointing towards center.
            # At Top (-90), we want Down (90). Diff = 180.
            # At Right (0), we want Left (180). Diff = 180.
            painter.rotate(screen_angle_deg + 180) 
            
            # Triangle
            painter.setPen(QPen(QColor(0,0,0), 1))
            painter.setBrush(QBrush(color))
            path = QPainterPath()
            path.moveTo(0, -6)
            path.lineTo(0, 6)
            path.lineTo(14, 0) 
            path.closeSubpath()
            painter.drawPath(path)
                
            painter.restore()
            
            # Label
            if label_text:
                 lx = x + math.cos(item_rad) * (radius + 20)
                 ly = y + math.sin(item_rad) * (radius + 20)
                 painter.setFont(QFont("Arial", 8, QFont.Weight.Bold))
                 text_w = fm.horizontalAdvance(label_text)
                 painter.setPen(QPen(QColor(0,0,0), 2))
                 painter.drawText(int(lx - text_w/2), int(ly), label_text) 
                 painter.setPen(QColor(255,255,255))
                 painter.drawText(int(lx - text_w/2), int(ly), label_text)

        # Draw Fixed Heading Marker (Numeric Text + Triangle) at Top
        
        # 1. Numeric Text "HDG"
        heading_val = int((heading_deg + 90) % 360)
        heading_str = f"{heading_val:03d}"
        
        painter.setFont(QFont("Arial", 11, QFont.Weight.Bold))
        fm = painter.fontMetrics()
        hw = fm.horizontalAdvance(heading_str)
        
        text_y = y - radius - 25 
        # Outline
        painter.setPen(QPen(QColor(0,0,0), 3))
        painter.drawText(int(x - hw/2), int(text_y), heading_str)
        # Fill
        painter.setPen(QColor(255,255,255)) 
        painter.drawText(int(x - hw/2), int(text_y), heading_str)
        
        # 2. Fixed Triangle at Top
        tip_x = x
        tip_y = y - radius - 5
        base_y = tip_y - 12
        
        path = QPainterPath()
        path.moveTo(tip_x, tip_y)
        path.lineTo(tip_x - 6, base_y)
        path.lineTo(tip_x + 6, base_y)
        path.closeSubpath()
        
        painter.setPen(QPen(QColor(0,0,0), 1))
        # Use configured color
        config_color = QColor(CONFIG.get('color', '#FFFF00'))

        painter.setPen(QPen(QColor(0,0,0), 1))
        painter.setBrush(config_color)
        painter.drawPath(path)
        
        # 3. Center Player Arrow (Fixed Up)
        # config_color already defined above
        painter.setBrush(QBrush(config_color)) 
        scale = 1.5
        
        path = QPainterPath()
        path.moveTo(x, y - 10 * scale)
        path.lineTo(x - 6 * scale, y + 8 * scale)
        path.lineTo(x, y + 4 * scale) 
        path.lineTo(x + 6 * scale, y + 8 * scale)
        path.closeSubpath()
        
        painter.setPen(QPen(QColor(0,0,0), 2))
        painter.drawPath(path)
        
        painter.setBrush(Qt.BrushStyle.NoBrush)

